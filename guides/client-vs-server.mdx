---
title: 'Client vs Server Keys'
description: 'Understanding when to use client keys vs server keys'
---

## Overview

Vouch provides two distinct API key types designed for different environments. Understanding when to use each type is crucial for both security and functionality.

## Key Differences

<CardGroup cols={2}>
  <Card title="Client Keys" icon="browser" color="#3b82f6">
    **Environment:** Browser & Mobile Apps

    - Prefix: `ck_`
    - Rate Limit: 1,000/hour
    - Domain Restricted: Yes
    - Can Override IP: No
    - Safe to Expose: Yes
  </Card>

  <Card title="Server Keys" icon="server" color="#8b5cf6">
    **Environment:** Backend Services

    - Prefix: `sk_`
    - Rate Limit: 5,000/hour
    - Domain Restricted: No
    - Can Override IP: Yes
    - Safe to Expose: No
  </Card>
</CardGroup>

## Detailed Comparison

| Feature | Client Key | Server Key |
|---------|------------|------------|
| **Environment** | Browser, mobile apps | Backend servers |
| **Rate Limit** | 1,000 requests/hour | 5,000 requests/hour |
| **Domain Restriction** | Must match allowed domains | No restrictions |
| **IP Override** | Cannot override | Can override |
| **User-Agent Override** | Cannot override | Can override |
| **Device Fingerprinting** | Automatic | Optional |
| **Browser Protection** | N/A | Blocked in browsers |
| **Security** | Safe to expose | Must remain secret |
| **Key Prefix** | `ck_test_` or `ck_live_` | `sk_test_` or `sk_live_` |

## When to Use Client Keys

### ✅ Use Client Keys For:

<AccordionGroup>
  <Accordion title="Single Page Applications (SPAs)" icon="react">
    ```javascript
    // React, Vue, Angular, Svelte
    import Vouch from '@vouch/js';

    const vouch = new Vouch(
      process.env.NEXT_PUBLIC_VOUCH_PROJECT_ID,
      process.env.NEXT_PUBLIC_VOUCH_CLIENT_KEY // Client key
    );

    const result = await vouch.validate(email);
    ```

    **Why:** Client keys are designed to be exposed in browser code and are protected by domain restrictions.
  </Accordion>

  <Accordion title="Mobile Applications" icon="mobile">
    ```swift
    // iOS
    let vouch = Vouch(
        projectId: "proj_...",
        apiKey: "ck_live_..." // Client key
    )
    ```

    ```kotlin
    // Android
    val vouch = Vouch(
        projectId = "proj_...",
        apiKey = "ck_live_..." // Client key
    )
    ```

    **Why:** Mobile apps bundle code that can be reverse-engineered. Client keys are safe even if exposed.
  </Accordion>

  <Accordion title="Static Site Generators" icon="file-code">
    ```javascript
    // Next.js, Gatsby, Astro
    export default function ContactForm() {
      const vouch = new Vouch(
        process.env.NEXT_PUBLIC_VOUCH_PROJECT_ID,
        process.env.NEXT_PUBLIC_VOUCH_CLIENT_KEY
      );

      // Validate email on form submission
    }
    ```

    **Why:** Static sites run entirely in the browser, requiring client keys.
  </Accordion>

  <Accordion title="Progressive Web Apps (PWAs)" icon="window-maximize">
    ```javascript
    // PWA Service Worker
    self.addEventListener('fetch', async (event) => {
      if (event.request.url.includes('/validate')) {
        const vouch = new Vouch(projectId, clientKey);
        // Handle validation
      }
    });
    ```

    **Why:** PWAs run client-side code and need client keys.
  </Accordion>
</AccordionGroup>

### Client Key Benefits

<CardGroup cols={2}>
  <Card title="Automatic Device Fingerprinting" icon="fingerprint">
    Client keys automatically collect device signals for fraud detection without additional configuration.
  </Card>

  <Card title="Domain Protection" icon="shield">
    Keys only work from configured domains, preventing unauthorized use even if exposed.
  </Card>

  <Card title="Safe to Deploy" icon="check">
    Can be committed to public repositories or exposed in client bundles without security risk.
  </Card>

  <Card title="Immediate Feedback" icon="bolt">
    Validate emails before form submission for instant user feedback.
  </Card>
</CardGroup>

## When to Use Server Keys

### ✅ Use Server Keys For:

<AccordionGroup>
  <Accordion title="Backend APIs" icon="code">
    ```javascript
    // Express.js
    import Vouch from '@vouch/node';

    const vouch = new Vouch(
      process.env.VOUCH_PROJECT_ID,
      process.env.VOUCH_SERVER_KEY // Server key
    );

    app.post('/api/users', async (req, res) => {
      const result = await vouch.validate(req.body.email);
      // Create user if valid
    });
    ```

    **Why:** Server-side validation is authoritative and cannot be bypassed by users.
  </Accordion>

  <Accordion title="Batch Processing" icon="list">
    ```javascript
    // Process multiple emails
    async function processEmailBatch(emails) {
      const vouch = new Vouch(
        process.env.VOUCH_PROJECT_ID,
        process.env.VOUCH_SERVER_KEY
      );

      const results = await Promise.all(
        emails.map(email => vouch.validate(email))
      );

      return results;
    }
    ```

    **Why:** Server keys have higher rate limits (5,000/hour) for bulk operations.
  </Accordion>

  <Accordion title="Webhooks & Background Jobs" icon="webhook">
    ```javascript
    // Background job
    async function validateNewSignups() {
      const vouch = new Vouch(projectId, serverKey);

      const recentSignups = await getRecentSignups();

      for (const signup of recentSignups) {
        await vouch.validate(signup.email);
      }
    }
    ```

    **Why:** Background processes run server-side and need server keys.
  </Accordion>

  <Accordion title="Admin Tools" icon="screwdriver-wrench">
    ```javascript
    // Admin dashboard API
    app.get('/admin/validate-users', async (req, res) => {
      const vouch = new Vouch(projectId, serverKey);

      const users = await getAllUsers();
      const validations = await Promise.all(
        users.map(u => vouch.validate(u.email))
      );

      res.json(validations);
    });
    ```

    **Why:** Admin tools run server-side and need higher rate limits.
  </Accordion>

  <Accordion title="IP Override Scenarios" icon="network-wired">
    ```javascript
    // Validate with user's actual IP
    const result = await vouch.validate(email, {
      ip: req.headers['x-forwarded-for'],
      userAgent: req.headers['user-agent']
    });
    ```

    **Why:** Only server keys can override IP and User-Agent for accurate fraud detection.
  </Accordion>
</AccordionGroup>

### Server Key Benefits

<CardGroup cols={2}>
  <Card title="Higher Rate Limits" icon="gauge-high">
    5,000 requests/hour vs 1,000 for client keys - ideal for bulk operations.
  </Card>

  <Card title="IP Override" icon="location-dot">
    Pass the end user's actual IP address for accurate fraud detection behind proxies.
  </Card>

  <Card title="Authoritative Validation" icon="check-double">
    Cannot be bypassed or tampered with by end users.
  </Card>

  <Card title="No Domain Restrictions" icon="globe">
    Works from any server without domain configuration.
  </Card>
</CardGroup>

## Architecture Patterns

### Pattern 1: Client-Only Validation

**Use case:** Simple forms, low-risk signups

```typescript
// Frontend only
const vouch = new Vouch(projectId, clientKey);
const result = await vouch.validate(email);

if (!result.success || !result.data) {
  showError(result.error || 'Invalid email');
} else if (!result.data.checks.syntax?.pass || !result.data.checks.disposable?.pass) {
  showError('Invalid email');
}
```

**Pros:**
- Instant feedback
- No backend required
- Reduces server load

**Cons:**
- Can be bypassed
- Lower rate limits

### Pattern 2: Server-Only Validation

**Use case:** High-security requirements, batch processing

```typescript
// Backend only
app.post('/signup', async (req, res) => {
  const vouch = new Vouch(projectId, serverKey);
  const result = await vouch.validate(req.body.email);

  if (!result.success || !result.data) {
    return res.status(result.statusCode || 400).json({
      error: result.error || 'Validation failed'
    });
  }

  if (!result.data.checks.syntax?.pass || !result.data.checks.disposable?.pass) {
    return res.status(400).json({ error: 'Invalid email' });
  }

  // Create account
});
```

**Pros:**
- Cannot be bypassed
- Higher rate limits
- Authoritative

**Cons:**
- Slower feedback
- More server requests

### Pattern 3: Hybrid Validation (Recommended)

**Use case:** Production applications requiring both UX and security

```typescript
// Client-side (immediate feedback)
const clientVouch = new Vouch(projectId, clientKey);
const clientResult = await clientVouch.validate(email);

if (!clientResult.success || !clientResult.data) {
  showError(clientResult.error || 'Invalid email');
  return;
}

if (!clientResult.data.checks.syntax?.pass || !clientResult.data.checks.disposable?.pass) {
  showError('Invalid email');
  return;
}

// Server-side (authoritative)
await fetch('/api/signup', {
  method: 'POST',
  body: JSON.stringify({ email })
});

// Backend validates again
app.post('/api/signup', async (req, res) => {
  const vouch = new Vouch(projectId, serverKey);
  const result = await vouch.validate(req.body.email);

  if (!result.success || !result.data) {
    return res.status(result.statusCode || 400).json({
      error: result.error || 'Validation failed'
    });
  }

  if (!result.data.checks.syntax?.pass || !result.data.checks.disposable?.pass) {
    return res.status(400).json({ error: 'Invalid email' });
  }
});
```

**Pros:**
- Instant user feedback
- Cannot be bypassed
- Best user experience
- Maximum security

**Cons:**
- Uses more quota
- Slightly more complex

<Info>
  Hybrid validation provides the best balance of user experience and security. The client check gives immediate feedback, while the server check ensures validation cannot be bypassed.
</Info>

## Security Considerations

### Client Keys

<AccordionGroup>
  <Accordion title="Domain Configuration" icon="shield">
    Always configure allowed domains:

    ```bash
    # Development
    localhost:*
    *.local

    # Production
    yourdomain.com
    *.yourdomain.com
    app.yourdomain.com
    ```

    Requests from other domains will be rejected with `DOMAIN_NOT_ALLOWED` error.
  </Accordion>

  <Accordion title="Key Rotation" icon="rotate">
    Rotate client keys if:
    - Domain list changes significantly
    - Suspected unauthorized use
    - Regular security policy (every 90 days)

    ```javascript
    // Support both old and new keys during rotation
    const PRIMARY_KEY = 'ck_live_new...';
    const FALLBACK_KEY = 'ck_live_old...';
    ```
  </Accordion>
</AccordionGroup>

### Server Keys

<AccordionGroup>
  <Accordion title="Environment Variables" icon="lock">
    Never hardcode server keys:

    ```javascript
    // ❌ Bad
    const vouch = new Vouch('proj_...', 'sk_live_...');

    // ✅ Good
    const vouch = new Vouch(
      process.env.VOUCH_PROJECT_ID,
      process.env.VOUCH_SERVER_KEY
    );
    ```
  </Accordion>

  <Accordion title="Secrets Management" icon="key">
    Use proper secrets management:

    ```bash
    # AWS Secrets Manager
    aws secretsmanager create-secret \
      --name vouch-server-key \
      --secret-string sk_live_...

    # HashiCorp Vault
    vault kv put secret/vouch api_key=sk_live_...

    # Kubernetes Secrets
    kubectl create secret generic vouch-keys \
      --from-literal=server-key=sk_live_...
    ```
  </Accordion>
</AccordionGroup>

## Common Mistakes

### ❌ Using Server Key in Browser

```javascript
// This will be blocked!
const vouch = new Vouch(projectId, 'sk_live_...');
await vouch.validate(email);

// Error: INVALID_KEY_TYPE
// "Server keys cannot be used in browsers"
```

### ❌ Exposing Server Key in Client Code

```javascript
// Never do this!
const VOUCH_SERVER_KEY = 'sk_live_...'; // Exposed in bundle
```

### ❌ Using Client Key for Batch Processing

```javascript
// This will hit rate limits!
const vouch = new Vouch(projectId, clientKey); // 1,000/hour

for (const email of 5000emails) { // Will fail
  await vouch.validate(email);
}
```

### ✅ Correct Approach

```javascript
// Client-side
const clientVouch = new Vouch(
  process.env.NEXT_PUBLIC_PROJECT_ID,
  process.env.NEXT_PUBLIC_CLIENT_KEY
);

// Server-side
const serverVouch = new Vouch(
  process.env.VOUCH_PROJECT_ID,
  process.env.VOUCH_SERVER_KEY
);
```

## Migration Guide

### From Client to Server Key

If you need to move validation server-side:

```typescript
// Before (client)
const vouch = new Vouch(projectId, clientKey);
const result = await vouch.validate(email);

// After (server)
// Frontend
await fetch('/api/validate', {
  method: 'POST',
  body: JSON.stringify({ email })
});

// Backend
app.post('/api/validate', async (req, res) => {
  const vouch = new Vouch(projectId, serverKey);
  const result = await vouch.validate(req.body.email);
  res.json(result);
});
```

### From Server to Hybrid

If you want to add client-side validation:

```typescript
// Add client validation for UX
const clientVouch = new Vouch(projectId, clientKey);
const quickCheck = await clientVouch.validate(email);

if (!quickCheck.success || !quickCheck.data) {
  showError(quickCheck.error);
  return;
}

if (!quickCheck.data.checks.syntax?.pass || !quickCheck.data.checks.disposable?.pass) {
  showError();
  return;
}

// Keep existing server validation
await fetch('/api/signup', { ... });
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Authentication Guide" icon="key" href="/guides/authentication">
    Complete authentication patterns
  </Card>

  <Card title="Rate Limits" icon="gauge" href="/guides/rate-limits">
    Understanding rate limits
  </Card>

  <Card title="Best Practices" icon="star" href="/guides/best-practices">
    Integration best practices
  </Card>

  <Card title="API Keys" icon="screwdriver-wrench" href="/dashboard/api-keys">
    Manage your API keys
  </Card>
</CardGroup>
